// This lib handles the player list cache, which is generated by the Rust code
// See `rust` directory for the script.

import { readFile, open } from 'node:fs/promises';
import { resolve } from 'node:path';

const FILE_PATH = resolve('./cache', 'points_ranks_by_name.bin');
const EXPECTED_VERSION = 1;

let lastUpdate = 0;
let buf: Buffer | null = null;
let prefixCache: { [key: string]: { name: string; points: number }[] } = {};
let numItems = -1;
let loadCallback: (() => void)[] | null = null;
let lastCheck = 0;

export const updateData = async () => {
	try {
		// do now reload if it's less than 60s since last check
		if (buf && Date.now() - lastCheck < 60000) {
			return;
		}

		// if it is currently loading, wait for it to finish
		if (loadCallback) {
			const lcbs = loadCallback;
			return new Promise<void>((resolve) => {
				lcbs.push(resolve);
			});
		}

		// start loading
		loadCallback = [];
		lastCheck = Date.now();
		const file = await open(FILE_PATH, 'r');
		const fileModifiedTime = (await file.stat()).mtimeMs;
		if (buf && fileModifiedTime == lastUpdate) {
			// no need to update
			return;
		}

		let newBuf: Buffer = await readFile(file);
		if (newBuf.length < 16) {
			return;
		}

		const version = newBuf.readUInt32LE(0);
		if (version != EXPECTED_VERSION) {
			return;
		}

		buf = newBuf;
		const _unused_totalPoints = buf.readInt32LE(4);
		numItems = buf.readUInt32LE(8);
		const cachePointer = buf.readUInt32LE(12);

		prefixCache = {};
		const numCacheItems = buf.readUInt32LE(cachePointer);
		let position = cachePointer + 4;
		for (let i = 0; i < numCacheItems; i++) {
			const prefixLen = buf.readUInt32LE(position);
			position += 4;
			const prefix = buf.toString('utf8', position, position + prefixLen);
			position += prefixLen;
			const count = buf.readUInt32LE(position);
			position += 4;
			const top10: { name: string; points: number }[] = [];
			for (let j = 0; j < count; j++) {
				const nameLen = buf.readUInt32LE(position);
				position += 4;
				const name = buf.toString('utf8', position, position + nameLen);
				position += nameLen;
				const points = buf.readInt32LE(position);
				position += 4;
				top10.push({ name, points });
			}
			prefixCache[prefix] = top10;
		}
		loadCallback = null;
	} catch (_) {
		buf = null;
		return;
	}
};

const getNameBuffer = (index: number) => {
	if (!buf) throw new Error('Can not get name buffer, data is not loaded');

	const pointer = buf.readUInt32LE(16 + index * 4);
	const nameLen = buf.readUInt8(pointer + 4);
	const nameStart = pointer + 5;
	const name = buf.toString('utf8', nameStart, nameStart + nameLen);
	const lowerCaseName = name.toLowerCase();
	const buffer = Buffer.from(lowerCaseName, 'utf-8');
	return buffer;
};

const readItem = (index: number) => {
	if (!buf) throw new Error('Can not get name buffer, data is not loaded');

	const pointer = buf.readUInt32LE(16 + index * 4);
	const points = buf.readInt32LE(pointer);
	const nameLen = buf.readUInt8(pointer + 4);
	const nameStart = pointer + 5;
	const pointsStart = nameStart + nameLen;
	const name = buf.toString('utf8', nameStart, pointsStart);
	return { name, points };
};

const binarySearchRange = (target: Uint8Array) => {
	let start = 0;
	let end = numItems;
	while (start < end) {
		const mid = Math.floor((start + end) / 2);
		const name = getNameBuffer(mid);
		if (name.compare(target) < 0) {
			start = mid + 1;
		} else {
			end = mid;
		}
	}

	const rangeStart = start;

	start = 0;
	end = numItems;

	const endTarget = Uint8Array.prototype.slice.call(target);
	for (let i = endTarget.length - 1; i >= 0; i--) {
		// increment the end target by one
		if (endTarget[i] == 0xff) {
			endTarget[i] = 0x00;
		} else {
			endTarget[i]++;
			break;
		}
	}

	while (start < end) {
		const mid = Math.floor((start + end) / 2);
		const name = getNameBuffer(mid);
		if (name.compare(endTarget) >= 0) {
			end = mid;
		} else {
			start = mid + 1;
		}
	}

	const rangeEnd = start;

	return {
		start: rangeStart,
		end: rangeEnd
	};
};

const binarySearchExact = (target: Uint8Array) => {
	let start = 0;
	let end = numItems;
	while (start < end) {
		const mid = Math.floor((start + end) / 2);
		const name = getNameBuffer(mid);
		const compare = name.compare(target);
		if (compare == 0) {
			return mid;
		}
		if (compare < 0) {
			start = mid + 1;
		} else {
			end = mid;
		}
	}
	return -1;
};

/**
 * Search for a player by name
 * @param name player name
 * @returns null if data is not loaded, {name: null, points: 0} if not found
 */
export const getPlayer = async (name: string) => {
	await updateData();
	if (!buf) return null;
	const index = binarySearchExact(
		Uint8Array.prototype.slice.call(Buffer.from(name.toLowerCase(), 'utf-8'))
	);
	if (index < 0) return { name: null, points: 0 };
	return readItem(index);
};

/**
 * Query player names starts with the given prefix
 * @param prefix player name prefix
 * @returns null if data is not loaded, otherwise an array of {name: string; points: number}[]
 */
export const queryPlayerPrefix = async (prefix: string) => {
	await updateData();
	if (!buf) return null;

	const top10: { name: string; points: number }[] = [];
	let exactMatch = -1;
	const searchBuf = Uint8Array.prototype.slice.call(Buffer.from(prefix.toLowerCase(), 'utf-8'));

	const cache = prefixCache[prefix];
	if (cache) {
		// use cache directly if it exists
		top10.push(...cache);
		exactMatch = binarySearchExact(searchBuf);
	} else {
		const range = binarySearchRange(searchBuf);
		for (let i = range.start; i < range.end; i++) {
			const item = readItem(i);
			if (item.name == prefix) {
				exactMatch = i;
			}
			// insert into the top10 array sorted by points
			let j = 0;
			while (j < top10.length && item.points < top10[j].points) {
				j++;
			}
			top10.splice(j, 0, item);
			if (top10.length > 10) {
				top10.pop();
			}
		}
	}

	// if there is exact match, insert it at the top
	if (exactMatch >= 0) {
		const exactMatchItem = readItem(exactMatch);
		top10.unshift(exactMatchItem);

		for (let i = 1; i < top10.length; i++) {
			// remove existing exact match
			if (top10[i].name == exactMatchItem.name) {
				top10.splice(i, 1);
				break;
			}
		}

		if (top10.length > 10) {
			top10.pop();
		}
	}

	return top10;
};
